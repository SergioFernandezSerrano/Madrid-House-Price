---
title: "Madrid House Price"
author: "Sergio Fernández, Miguel Ocón, Enrique Roa"
date: "`r format(Sys.Date(), '%d de %B de %Y')`"
output:
  html_document:
    code_folding: hide
    theme: flatly
    number_sections: yes
    toc: yes
    toc_depth: 2
    toc_float: yes
---


```{r setup, include=FALSE}
knitr::opts_chunk$set(
	echo = TRUE,
	include = TRUE,
	warning = FALSE,
	message = FALSE,
	fig.align = "center",
	out.width = "90%"
)
```

![](Gran_Vía_(Madrid)_1.jpg)

# Introducción y definición de objetivos

El análisis de datos en el mercado inmobiliario es algo muy común y que lleva muchísimos años  desarrollándose. Con el objetivo de predecir que aspectos influyen principalmente en el precio de las casas en Madrid, hemos seleccionado un dataset  ([kaggle - Madrid House Price](https://www.kaggle.com/datasets/kevsde/madrid-house-price)) con viviendas en venta de la capital española.

```{r}
library(readr)
library(dplyr)
library(tidyr)
library(kableExtra)
library(ggplot2)
library(GGally)
library(cowplot)
library(ggcorrplot)
library(gmodels)
library(caret)
library(ggfortify)
library(scales)
library(class)
library(distances)
library(rpart)
library(rpart.plot)
library(rattle)
library(randomForest)
library(e1071)
library(kernlab)
library(cluster)
library(tidyverse)
library(stringr)
library(Metrics)
library(factoextra)
library(NbClust)
```

```{r}
paste(R.Version()$version.string)
```
# Análisis exploratorio inicial

## Lectura y preparación de los datos

En esta primera etapa cargamos el dataset descargado y hacemos una observación superficial de las variables recogidas y sus características. Se representan también las 10 filas iniciales.

```{r}
mhp <- read_csv("house_price_madrid_14_08_2022.csv")
```

```{r}
head(mhp, 10) %>%
  kbl() %>%
  kable_material(c("striped", "hover")) %>%
  scroll_box(width = "100%", height = "350px")
```

```{r}
summary(mhp)
```

```{r}
str(mhp) 
```

El dataset contiene **15.975 observaciones** (correspondientes a una vivienda cada una) y **9 variables** (de las cuales son **6 cualitativas** y **3 cuantitativas**).

A continuación, la descripción de cada una de las variables:

  - **price**: precio
  
  - **house_type**: tipo de vivienda (casa, chalet, piso...)
  
  - **house_type_2**: si es exterior o interior
  
  - **rooms**: número de habitaciones
  
  - **m2**: metros cuadrados
  
  - **elevator**: si tiene ascensor
  
  - **garage**: si incluye garaje
  
  - **neighborhood**: barrio de Madrid
  
  - **district**: distrito de Madrid

Tras esta primera observación se harán algunas modificaciones en el dataset para transformar a variables de tipo categórico las que correspondan, así como transformar a binarias (1/0) aquellas con sólo dos valores posibles.

```{r}
# Preparación de los datos. Convertimos a factores las variables que son categóricas y a 1-0 las binarias.

mhp <- mhp %>% rename(exterior = house_type_2)
mhp$exterior = ifelse(mhp$exterior == "exterior", 1, 0)
mhp$exterior = factor(mhp$exterior, levels = c(1,0))

mhp$elevator = ifelse(mhp$elevator == "TRUE", 1, 0)
mhp$elevator = factor(mhp$elevator, levels = c(1,0))

mhp$garage = ifelse(mhp$garage == "TRUE", 1, 0)
mhp$garage = factor(mhp$garage, levels = c(1,0))

mhp$house_type <- as.factor(mhp$house_type)
mhp$exterior <- as.factor(mhp$exterior)
mhp$elevator <- as.factor(mhp$elevator)
mhp$garage <- as.factor(mhp$garage)
mhp$neighborhood <- as.factor(mhp$neighborhood)
mhp$district <- as.factor(mhp$district)
```

## Tratamiento de datos faltantes

Convertimos en NA aquellas observaciones que claramente contienen algún error:

  - La casa de 41 habitaciones (probablemente fueran 4 y esté mal imputado)
  
  - Las que tienen menos de 3 m2 (probablemente mal imputados al usar el punto para separar los miles)
  
  - La casa con un precio de 725 (claramente equivocado).

```{r}
mhp$rooms[mhp$rooms > 40] <- NA
mhp$m2[mhp$m2 < 3] <- NA
mhp$price[mhp$price < 1000] <- NA
```

Por otro lado, la variable **house_type_2** tiene 469 filas sin datos. Junto a los NA añadidos en el paso anterior son el 3.2% del total, por lo que optaremos por eliminar estas filas del dataset.

```{r}
sum(is.na(mhp))/nrow(mhp)
mhp <- na.omit(mhp)
```

## División del dataset

Para finalizar la preparación de los datos, dividiremos nuestro dataset en tres partes, una de entrenamiento (train), con el que trabajaremos durante todo el análisis, otra de prueba (test) que nos servirá para comprobar la eficacia de los diferentes modelos predictivos que se apliquen, y finalmente uno de validación (validation), que se mantendrá sin usar hasta el último día del proyecto y con el cual validaremos el modelo final.

```{r}
set.seed(108)
numero_total = nrow(mhp)
# Porcentajes de train, test y validation
w_train = .5
w_test = .25
w_validation = 1 - (w_train + w_test)

# Todos los índices
indices = seq(1:numero_total) 

# Muestreo
indices_train = sample(1:numero_total, numero_total * w_train)
indices_test = sample(indices[-indices_train], numero_total * w_test)
indices_validation = indices[-c(indices_train,indices_test)]

# Agrupamos

mhp_train = mhp[indices_train,]
mhp_test = mhp[indices_test,]
mhp_validation = mhp[indices_validation,]
```

# Análisis univariante

## Análisis de variables cualitativas

Una vez preparado el dataset comenzamos con el análisis de las variables cualitativas, que son las siguientes:

**Tipo de vivienda**

```{r}
merge(setNames(as.data.frame(table(mhp_train$house_type)), c("house_type", "count")),
      setNames(as.data.frame(round(prop.table(table(mhp_train$house_type))*100, 2)), c("house_type", "prop (%)"))
) %>%
  arrange(desc(count)) %>%
  kbl() %>%
  kable_material(c("striped", "hover")) %>%
  scroll_box(width = "100%", height = "350px")
```

```{r}
ggplot(mhp_train, aes(house_type)) +
  geom_bar(fill = "#0BB363") +
  coord_flip() +
  labs(x = "Tipo de vivienda", y = "Número de viviendas", title = "Viviendas por tipo") +
  theme(plot.title = element_text(hjust = 0.5))
```

Como era de esperar, las viviendas más habituales son pisos en plantas no demasiado altas (bajos, primeros, segundos...). El número de casas y chalets también es pequeño en proporción.

**Orientación exterior**

```{r}
merge(setNames(as.data.frame(table(mhp_train$exterior)), c("exterior", "count")),
      setNames(as.data.frame(round(prop.table(table(mhp_train$exterior))*100, 2)), c("exterior", "prop (%)"))
) %>%
  kbl() %>%
  kable_material(c("striped", "hover"))
```

```{r}
ggplot(mhp_train, aes(exterior)) +
  geom_bar(fill = "#0BB363") +
  labs(x = "Exterior", y = "Número de vivienda de viviendas", title = "Viviendas exteriores") +
  theme(plot.title = element_text(hjust = 0.5))
```

Son una inmensa mayoría los pisos que dan a exterior.

**Ascensor**

```{r}
merge(setNames(as.data.frame(table(mhp_train$elevator)), c("elevator", "count")),
      setNames(as.data.frame(round(prop.table(table(mhp_train$elevator))*100, 2)), c("elevator", "prop (%)"))
) %>%
  kbl() %>%
  kable_material(c("striped", "hover"))
```

```{r}
ggplot(mhp_train, aes(elevator)) +
  geom_bar(fill = "#0BB363") +
  labs(x = "Ascensor", y = "Número de viviendas", title = "Viviendas con ascensor") +
  theme(plot.title = element_text(hjust = 0.5))
```

También es más frecuente que tengan ascensor, aunque casi el 30% no lo tienen.

**Garaje**

```{r}
merge(setNames(as.data.frame(table(mhp_train$garage)), c("garage", "count")),
      setNames(as.data.frame(round(prop.table(table(mhp_train$garage))*100, 2)), c("garage", "prop (%)"))
) %>%
  kbl() %>%
  kable_material(c("striped", "hover"))
```

```{r}
ggplot(mhp_train, aes(garage)) +
  geom_bar(fill = "#0BB363") +
  labs(x = "Garaje", y = "Número de viviendas", title = "Viviendas con garaje") +
  theme(plot.title = element_text(hjust = 0.5))
```

Parece normal que la mayoría de pisos no tuvieran garaje incluido.

**Barrio**

Esta variable no será muy útil para el análisis, ya que en muchos casos son descripciones de la vivienda hechas por el usuario, por lo que habría que hacer un tratamiento previo para poder agruparlas. Algo innecesario ya que ese mismo efecto se consigue con el siguiente campo: distritos.

```{r}
merge(setNames(as.data.frame(table(mhp_train$neighborhood)), c("neighborhood", "count")),
      setNames(as.data.frame(round(prop.table(table(mhp_train$neighborhood))*100, 2)), c("neighborhood", "prop (%)"))
) %>%
  kbl() %>%
  kable_material(c("striped", "hover")) %>%
  scroll_box(width = "100%", height = "350px")
```

**Distrito**

En este caso los datos si están correctamente recogidos, repartiendo las casas entre los 21 distritos de Madrid.Casi todos con una representación considerable, en lo que destaca el barrio de Salamanca, con casi el doble de viviendas que el segundo que más tiene, Chamberí.

```{r}
merge(setNames(as.data.frame(table(mhp_train$district)), c("district", "count")),
      setNames(as.data.frame(round(prop.table(table(mhp_train$district))*100, 2)), c("district", "prop (%)"))
) %>%
  arrange(desc(count)) %>%
  kbl() %>%
  kable_material(c("striped", "hover")) %>%
  scroll_box(width = "100%", height = "350px")
```

```{r}
ggplot(mhp_train, aes(district)) +
  geom_bar(fill = "#0BB363") +
  labs(x = "Distrito", y = "Número de viviendas", title = "Viviendas por distrito") +
  theme(plot.title = element_text(hjust = 0.5), axis.text.x = element_text(angle = 30, hjust = 1))
```

## Análisis de variables cuantitativas

**Precio**

```{r}
data.frame(summarise(mhp_train,
                     min = min(price),
                     max = max(price),
                     median = median(price),
                     mean = mean(price),
                     sd = sd(price))) %>%
  kbl() %>%
  kable_material(c("striped", "hover"))
```

```{r}
ggplot(mhp_train, aes(y = price)) +
  geom_boxplot(fill = "#0BB363") +
  labs(y = "Precio", title = "Boxplot de precios") +
  theme(plot.title = element_text(hjust = 0.5), axis.text.x = element_text(angle = 30, hjust = 1))
```

```{r}
ggplot(mhp_train, aes(price)) +
  geom_histogram(aes(y=..density..), bins = 50, position = "dodge", fill = "#0BB363") +
  geom_density(alpha=.3, fill = "red") +
  labs(x = "Precio", y = "Número de viviendas", title = "Viviendas por Precio") +
  scale_x_continuous(breaks = pretty(mhp_train$price, n = 10),labels = comma_format()) +
  scale_y_continuous(labels = comma_format()) +
  theme(plot.title = element_text(hjust = 0.5), axis.text.x = element_text(angle = 30))
```

**Habitaciones**

```{r}
data.frame(summarise(mhp_train,
                     min = min(rooms),
                     max = max(rooms),
                     median = median(rooms),
                     mean = mean(rooms),
                     sd = sd(rooms))) %>%
  kbl() %>%
  kable_material(c("striped", "hover"))
```

```{r}
ggplot(mhp_train, aes(y = rooms)) +
  geom_boxplot(fill = "#0BB363") +
  labs(y = "Habitaciones", title = "Boxplot de habitaciones") +
  theme(plot.title = element_text(hjust = 0.5), axis.text.x = element_text(angle = 30, hjust = 1))
```

```{r}
ggplot(mhp_train, aes(rooms)) +
  geom_histogram(aes(), bins = 16, position = "dodge", fill = "#0BB363") +
  geom_density(alpha=.2, fill = "red") +
  labs(x = "Habitaciones", y = "Número de viviendas", title = "Viviendas por número de habitaciones") +
  theme(plot.title = element_text(hjust = 0.5))
```

**m²**

```{r}
data.frame(summarise(mhp_train,
                     min = min(m2),
                     max = max(m2),
                     median = median(m2),
                     mean = mean(m2),
                     sd = sd(m2))) %>%
  kbl() %>%
  kable_material(c("striped", "hover"))
```

```{r}
ggplot(mhp_train, aes(y = m2)) +
  geom_boxplot(fill = "#0BB363") +
  labs(y = "Metros cuadrados", title = "Boxplot de superficies") +
  theme(plot.title = element_text(hjust = 0.5), axis.text.x = element_text(angle = 30, hjust = 1))
```

```{r}
ggplot(mhp_train, aes(m2)) +
  geom_histogram(aes(y=..density..), bins = 50, position = "dodge", fill = "#0BB363") +
  geom_density(alpha=.3, fill = "red") +
  labs(x = "Metros cuadrados", y = "Número de viviendas", title = "Viviendas por metros cuadrados") +
  theme(plot.title = element_text(hjust = 0.5))
```

# Análisis multivariante

Una vez analizadas todas las variables de forma individual, podemos buscar algunas relaciones entre ellas.

Como se ve en los gráficos inferiores hay una relción fuerte entre el precio, los metros cuadradados y el número de habitaciones.

```{r}
plot_grid(
  ggcorrplot(cor(mhp_train %>% select_if(is.numeric)),type = "lower", lab=TRUE),
  
  ggplot(mhp_train, aes(x = m2, y = price)) +
  geom_point() +
  geom_smooth() +
  ggtitle('Reación precio y m²') +
  theme(plot.title = element_text(hjust = 0.5)),
  
  ggplot(mhp_train, aes(x = rooms, y = price)) +
  geom_point() +
  geom_smooth() +
  ggtitle('Reación precio y habitaciones') +
  theme(plot.title = element_text(hjust = 0.5)), 
  
  ggplot(mhp_train, aes(x = rooms, y = m2)) +
  geom_point() +
  geom_smooth() +
  ggtitle('Reación m² y habitaciones') +
  theme(plot.title = element_text(hjust = 0.5)), 
  
  nrow = 2
)
```

Introduciendo algunas de las variables categóricas se puede observar como varía el precio con la superficie o el número de habitaciones dependiendo de si incluye garaje, ascensor u orientación exterior.

```{r}
plot_grid(
  ggplot(mhp_train, aes(x = m2, y = price, colour = exterior)) +
  geom_point() +
  geom_smooth(method = "lm") +
  scale_colour_manual(values = c("1" = "#0BB363", "0" = "#DC143C")) +
  ggtitle('Rel. precio-superficie, exterior') ,
  
  ggplot(mhp_train, aes(x = rooms, y = price, colour = exterior)) +
  geom_point() +
  geom_smooth(method = "lm") +
  scale_colour_manual(values = c("1" = "#0BB363", "0" = "#DC143C")) + 
  ggtitle('Rel. precio-habitaciones, exterior') ,
  
  nrow =1
)
```

```{r}
plot_grid(
  ggplot(mhp_train, aes(x = m2, y = price, colour = elevator)) +
  geom_point() +
  geom_smooth(method = "lm") +
  scale_colour_manual(values = c("1" = "#0BB363", "0" = "#DC143C")) +
  ggtitle('Rel. precio-superficie, ascensor'),
  
  ggplot(mhp_train, aes(x = rooms, y = price, colour = elevator)) +
  geom_point() +
  geom_smooth(method = "lm") +
  scale_colour_manual(values = c("1" = "#0BB363", "0" = "#DC143C")) +
  ggtitle('Rel. precio-habitación, ascensor'),
  
  nrow =1
)
```

```{r}
plot_grid(
  ggplot(mhp_train, aes(x = m2, y = price, colour = garage)) +
  geom_point() +
  geom_smooth(method = "lm") +
  scale_colour_manual(values = c("1" = "#0BB363", "0" = "#DC143C")) +
  ggtitle('Rel. precio-superficie, garaje'),
  
  ggplot(mhp_train, aes(x = rooms, y = price, colour = garage)) +
  geom_point() +
  geom_smooth(method = "lm") +
  scale_colour_manual(values = c("1" = "#0BB363", "0" = "#DC143C")) +
  ggtitle('Rel. precio-habitaciones, garaje'),
  
  nrow =1
)
```

Representando boxplot por distrito se ve claramente que los barrios ricos como Salamanca o Chamberí, a parte de tener precios medios más altos, tienen mayor número de viviendas con precios atípicos (por encima), mientras que en el número de habitaciones no se aprecia una diferencia tan notoria.

```{r}
ggplot(mhp_train, aes(district, price)) +
  geom_boxplot(fill = "#0BB363") +
  labs(y = "Precio", title = "Boxplot de precios por distrito") +
  theme(plot.title = element_text(hjust = 0.5), axis.text.x = element_text(angle = 30, hjust = 1))
```

```{r}
ggplot(mhp_train, aes(district, rooms)) +
  geom_boxplot(fill = "#0BB363") +
  labs(y = "Habitaciones", title = "Boxplot de habitaciones por distrito") +
  theme(plot.title = element_text(hjust = 0.5), axis.text.x = element_text(angle = 30, hjust = 1))
```

```{r}
ggplot(mhp_train, aes(district, m2)) +
  geom_boxplot(fill = "#0BB363") +
  labs(y = "Metros cuadrados", title = "Boxplot de superficie por distrito") +
  theme(plot.title = element_text(hjust = 0.5), axis.text.x = element_text(angle = 30, hjust = 1))
```

En las siguientes figuras se representa el precio medio por distrito y como varía con respecto a otras variables de interés.

```{r}
mhp_train %>%
  group_by(district, m2) %>%
  summarize(avg_price = mean(price)) %>%
  ggplot(aes(x = m2, y = avg_price)) + 
  geom_point(size = 0.5) +
  facet_wrap(~ district)
```

```{r}
mhp_train %>%
  group_by(district, exterior) %>% 
  summarise(avg_price = mean(price)) %>%
  ggplot(aes(x=district, y=avg_price, fill=exterior)) +
  geom_bar(stat = "identity", position = "dodge") + 
  scale_fill_manual(values = c("1" = "#0BB363", "0" = "#DC143C")) +
  ggtitle("Precio medio por distrito y exterior") +
  theme(plot.title = element_text(hjust = 0.5), axis.text.x = element_text(angle = 30, hjust = 1)) + 
  labs(x = "Distrito", y = "Precio medio")
```

```{r}
mhp_train %>%
  group_by(district, elevator) %>% 
  summarise(avg_price = mean(price)) %>%
  ggplot(aes(x=district, y=avg_price, fill=elevator)) +
  geom_bar(stat = "identity", position = "dodge") + 
  scale_fill_manual(values = c("1" = "#0BB363", "0" = "#DC143C")) +
  ggtitle("Precio medio por distrito y ascensor") +
  theme(plot.title = element_text(hjust = 0.5), axis.text.x = element_text(angle = 30, hjust = 1)) + 
  labs(x = "Distrito", y = "Precio medio")
```

```{r}
mhp_train %>%
  group_by(district, garage) %>% 
  summarise(avg_price = mean(price)) %>%
  ggplot(aes(x=district, y=avg_price, fill=garage)) +
  geom_bar(stat = "identity", position = "dodge") + 
  scale_fill_manual(values = c("1" = "#0BB363", "0" = "#DC143C")) +
  ggtitle("Precio medio por distrito y garaje") +
  theme(plot.title = element_text(hjust = 0.5), axis.text.x = element_text(angle = 30, hjust = 1)) + 
  labs(x = "Distrito", y = "Precio medio")
```

# Procesado de variables cualitativas

```{r}
mhp_train %>%
  group_by(house_type) %>%
  summarise(precio_medio = mean(price)) %>%
  arrange(precio_medio)
```

Para el posterior análisis transformamos la columna house_type, agrupando en "piso" (independientemente de la planta en la que esté), "casa" (casa o chalet) y "sotano".

```{r}
mhp_train <- mhp_train %>%
  mutate(tipo_casa = case_when(
    grepl("casa|chalet", house_type, ignore.case = TRUE) ~ "casa",
    grepl("\\bplanta\\s*-?1\\b|semi-?sotano|bajo|sotano", house_type, ignore.case = TRUE) ~ "sotano",
    TRUE ~ "piso"
  ))
mhp_train$tipo_casa <- as.factor(mhp_train$tipo_casa)
```

También se agruparán los distritos en función del precio medio del mismo: caro, medio o barato.

```{r}
mhp_train <- mhp_train %>%
  group_by(district) %>%
  mutate(precio_distrito = mean(price)) %>%
  ungroup()

# Calcular los percentiles
percentiles <- quantile(mhp_train$precio_distrito, probs = c(0, 1/3, 2/3, 1))

# Asignar etiquetas
mhp_train$precio_distrito <- cut(mhp_train$precio_distrito, breaks = percentiles, labels = c("barato", "medio", "caro"), include.lowest = TRUE)
```

Además, de cara a desarrollar algunos modelos, se creará una variable target binaria que dividirá las casas entre "cara" y "barata" (1/0).

```{r}
mhp_train$precio_bin <- ifelse(mhp_train$price > median(mhp_train$price), "cara", "barata")
mhp_train$precio_bin = ifelse(mhp_train$precio_bin == "cara", 1, 0)
mhp_train$precio_bin = factor(mhp_train$precio_bin, levels = c(1,0))
```

```{r}
# Aplicamos todos los cambios también a test.

# Categorizamos house_type
mhp_test <- mhp_test %>%
  mutate(tipo_casa = case_when(
    grepl("casa|chalet", house_type, ignore.case = TRUE) ~ "casa",
    grepl("\\bplanta\\s*-?1\\b|semi-?sotano|bajo|sotano", house_type, ignore.case = TRUE) ~ "sotano",
    TRUE ~ "piso"
  ))
mhp_test$tipo_casa <- as.factor(mhp_test$tipo_casa)

# Categorizamos los distritos
mhp_test <- mhp_test %>%
  group_by(district) %>%
  mutate(precio_distrito = mean(price)) %>%
  ungroup()

percentiles <- quantile(mhp_test$precio_distrito, probs = c(0, 1/3, 2/3, 1))

mhp_test$precio_distrito <- cut(mhp_test$precio_distrito, breaks = percentiles, labels = c("barato", "medio", "caro"), include.lowest = TRUE)

# Creamos variable target
mhp_test$precio_bin <- ifelse(mhp_test$price > median(mhp_test$price), "cara", "barata")
mhp_test$precio_bin = ifelse(mhp_test$precio_bin == "cara", 1, 0)
mhp_test$precio_bin = factor(mhp_test$precio_bin, levels = c(1,0))
```

# Modelo de regresión lineal

Con el dataset ya preparado, se crea un modelo de regresión lineal.

En este caso, tras hacer diversas pruebas se ha optado por introducir sólo 3 variables (tipo_casa, m2 y precio_distrito), alcanzando un R2 de 0.7553.

Esta cifra podía incrementarse algo, sin embargo es a costa de introducir más variables y por tanto más complejidad al modelo, haciéndolo menos explicable.

```{r}
lm_fit <- lm(price ~ m2+tipo_casa+precio_distrito, data=mhp_train)
summary(lm_fit)
coef(lm_fit)
```

```{r}
residuals=lm_fit$residuals
autoplot(lm_fit)
```

Observando los residuos se ve como hay cierta heterocedasticidad y en la gráfica QQ no se ajustan a la normal, por lo que el módelo no es bueno.

```{r}
# Realizar predicciones en la partición test
predictions <- predict(lm_fit, newdata = mhp_test)

# Comparar las predicciones con los valores reales
rmse <- rmse(predictions, mhp_test$price)
mae <- mae(predictions, mhp_test$price)
r2 <- R2(predictions, mhp_test$price)

# Imprimir las métricas de evaluación
cat(paste0("RMSE: ", round(rmse, 2), "\n"))
cat(paste0("MAE: ", round(mae, 2), "\n"))
cat(paste0("R-squared: ", round(r2, 2)))
```

Un R2 de 0.73 (bastante similar al calculado en train) indica que se explica con esa probabilidad la variabilidad de la variable dependiente, por lo tanto podríamos considerarlo razonablemente útil, sin embargo sería preferible mejorar los valores del error de predicción promedio o el cuadrático.

# Conclusiones preliminares

El análisis realizado hasta el momento ha servido para familiarizarse con el mercado inmobiliario de Madrid (o al menos parte de él) y conocer como se comportan algunas de las variables más relevantes en el valor de las viviendas.

Con estos conocimientos se abordarán nuevos modelos para intentar conseguir mejores predicciones y simultaneamente comprender y desarrollar estos mismos modelos.

```{r}
str(mhp_train)
```

# Aprendizaje no supervisado

## K-Means

El algoritmo K-Means es un método de aprendizaje automático no supervisado utilizado para el análisis de agrupamiento o "clustering". El objetivo principal de este algoritmo es dividir los datos en K grupos (clusters), de modo que los puntos dentro de un mismo grupo sean lo más similares posible.

```{r}
mhp_train_kmeans <- subset(mhp_train, select = c("price", "m2", "rooms", "elevator", "garage", "exterior"))

mhp_train_kmeans$exterior <- as.numeric(mhp_train_kmeans$exterior)
mhp_train_kmeans$elevator <- as.numeric(mhp_train_kmeans$elevator)
mhp_train_kmeans$garage <- as.numeric(mhp_train_kmeans$garage)

# Normalizamos los datos
mhp_train_kmeans <- scale(mhp_train_kmeans)
```

Aplicamos k-means sólo para las variables numéricas. Utilizando la regla del codo vemos que lo correcto sería coger un k = 3. 

```{r}
fviz_nbclust(mhp_train_kmeans, kmeans, method = "wss")
fviz_nbclust(mhp_train_kmeans, kmeans, method = "silhouette")
```

Aplicamos el algoritmo con k = 7 y vemos el gráfico de clusters que nos crea con k-means.

```{r}
# Definir el número de grupos
k <- 7

# Ejecutar k-means
grupos <- kmeans(mhp_train_kmeans, k)

mhp_train$cluster <- as.factor(grupos$cluster)

# Graficar la relación entre las características y los grupos
ggplot(mhp_train, aes(x=m2, y=price, color=cluster)) + 
  geom_point() +
  ggtitle("Grupos de casas en venta") +
  theme(plot.title = element_text(hjust = 0.5)) +
  xlab("Tamaño en m2") +
  ylab("Precio")
```

```{r}
fviz_cluster(grupos, data = mhp_train_kmeans, ellipse.type = "euclid",repel = TRUE,star.plot = TRUE)
fviz_cluster(grupos, data = mhp_train_kmeans, ellipse.type = "norm")
```

# Técnicas de reducción de la dimensionalidad

## PCA

El Análisis de Componentes Principales es una técnica de reducción de la dimensionalidad que se utiliza para transformar un conjunto de datos de múltiples variables en un nuevo conjunto de datos con un número menor de variables cuyo principal objetivo es simplificar la representación de datos mientras se conserva la mayor cantidad de información y variabilidad posible identificando patrones y estructuras subyacentes reduciendo la multicolinealidad y el sobreajuste.

Dividimos el dataset quedándonos solo con las columnas numéricas y descartando la columna precio puesto que será de alguna manera nuestra variable dependiente.

```{r}
train_pca <- mhp_train[,c(3:7,10,11,12)]
```

Creamos 3 variables dummy usando variables categóricas de tipo 0|1.

```{r}
dummy_garaje <- model.matrix(~0 + garage,data = train_pca)
dummy_exterior <- model.matrix(~0 + exterior, data = train_pca)
dummy_ascensor <- model.matrix(~0 + elevator, data = train_pca)
dummy_tipo_casa <- model.matrix(~0 + tipo_casa, data = train_pca)
dummy_distrito <- model.matrix(~0 + precio_distrito, data = train_pca)
```

```{r}
dummy_data <- cbind(train_pca[, c("rooms", "m2")],dummy_exterior,dummy_garaje,dummy_ascensor,dummy_distrito,dummy_tipo_casa)
```

```{r}
prcomp(dummy_data)
```
Podemos observar que en la PC1 lleva un peso casi de 100 la variable m2. 
En PC2 pasa lo mismo con la variable rooms. En el resto de PCs el análisis de componentes principales está algo más repartido.

```{r}
summary(prcomp(dummy_data))
```
Al hacer un summary de las variables vemos que la proporción de varianza explicada por la primera componente es de un 99%, es decir, que es la única relevante. 
Si nos fijamos vemos que la PC1 está explicada casi al 100% por los m2. En nuestra tabla vemos que los m2 tienen valores mucho más altos que el resto de variables. Por lo tanto, lo que hacemos a continuación es un análisis pero escalando las variables.

```{r}
prcomp(dummy_data, scale = T)
```
Tras escalar las variables podemos observar que están mucho más repartidos los pesos en las componentes principales debido a que estás asegurando que todas las variables tengan la misma importancia en el análisis, independientemente de sus escalas originales y unidades de medida. Con esto evitas el dominio de variables con mayor magnitud y mejoras la interpretación de resultados. 


```{r}
pca_result <- prcomp(dummy_data, center = TRUE, scale = TRUE)
summary(pca_result)
```
Observamos que con PC6 ya llegamos al 80% de la proporción de varianza explicada pero vemos algunos saltos interesantes. Para ver cuantas componentes explican el modelo hacemos la regla de codo, método heurístico para determinar el número óptimo de clusters en un conjunto de datos.

```{r}
plot(pca_result,type = "l",
     main="Variance explained by PCA")
```
Al observar el gráfico vemos que la forma del codo sería en la 6|7 aunque  el gráfico no es muy claro. 

```{r}
plot(pca_result, main = "Gráfico PCA")
```

# Aprendizaje supervisado

## GLM

En aprendizaje automático Generalized Linear Models se refiere a una clase de modelos lineales que se utilizan para predecir una variable de respuesta a partir de una o más variables explicativas.
Se compone de tres componentes, Variable de respuesta, Función de enlace y Función lineal sistemática y son muy útiles para utilizarse en clasificación, regresión y problemas de predicción.

Aplicado a nuestro dataset nos ayudará a predecir el precio de las casas. Para ello realizamos las siguientes trasnformaciones.
Primero seleccionamos las variables.


```{r}
train_glm <- mhp_train[,c(3:7,10,11,12)]
test_glm <- mhp_test[,c(3:7,10,11,12)]
```

Escalamos las columnas de m2 y rooms.

```{r}
train_glm[,2:3]<- scale(train_glm[,2:3])
test_glm[,2:3]<- scale(test_glm[,2:3])
```

Desarrollamos el modelo con la variable de respuesta "precio_bin", y las variables independientes "exterior", "garage", "elevator", "rooms", "precio_distrito" y "tipo_casa" usando una distribución binomial. 

```{r}
glm_mhp = glm(formula = precio_bin ~ exterior + garage + elevator + rooms + precio_distrito + tipo_casa,
                 data = train_glm, 
                 family = binomial)
summary(glm_mhp)
```
En este caso, todos los coeficientes tienen valores "p" muy pequeños, lo que indica que todas las variables independientes tienen una relación significativa con la variable dependiente "precio_bin" en el modelo de regresión logística ajustado.

En particular, las variables "garage", "elevator", "rooms", "precio_distrito_medio", "precio_distrito_caro" y "plantas bajas" tienen una relación significativa y positiva con la probabilidad de que la vivienda sea "cara", mientras que la variable "rooms" tiene una relación negativa con la probabilidad de que la vivienda sea "cara". Esto no tiene mucho sentido puesto que a más habitaciones más probable que una casa sea cara.
El modelo explica una cantidad significativa de la varianza en la variable respuesta, con un AIC de 4904.4.

```{r}
head(predict(glm_mhp))
```
Esto sirve para predecir la probabilidad logit ajustado previamente y para mostrar las primeras seis predicciones.
Cada número representa la probabilidad logit de que la variable dependiente "precio_bin" sea igual a 1 para cada observación en el conjunto de datos.

```{r}
head(fitted(glm_mhp))
```

Aquí obtenemos las probabilidades ajustadas que representan las probabilidades estimadas de que la variable dependiente "precio_bin" sea igual a 1 para cada observación en el conjunto de datos.

```{r}
predicciones_glm <- ifelse(test = glm_mhp$fitted.values > 0.5, yes = 1, no = 0)
matriz_confusion_glm <- table(glm_mhp$model$precio_bin, predicciones_glm,
                          dnn = c("observaciones", "predicciones"))
matriz_confusion_glm
```

Finalmente generamos predicciones binarias basadas en las probabilidades ajustadas del modelo lineal generalizado y creamos una matriz de confusión para evaluar el rendimiento del modelo donde se muestra la distribución de las predicciones correctas e incorrectas en función de las observaciones reales y las predichas.

La matriz se lee de la siguiente manera:

-   Verdaderos negativos (VN): La esquina superior izquierda (3265) representa el número de observaciones clasificadas correctamente como "0" (clase negativa). Esto significa     que el modelo predijo correctamente 3265 casos como "0".

-   Falsos positivos (FP): La esquina superior derecha (598) representa el número de observaciones que en realidad eran "0" pero fueron clasificadas incorrectamente como "1"     (clase positiva) por el modelo. El modelo cometió un error en 598 casos al clasificarlos como "1".

-   Falsos negativos (FN): La esquina inferior izquierda (501) representa el número de observaciones que en realidad eran "1" pero fueron clasificadas incorrectamente como       "0" por el modelo. El modelo cometió un error en 501 casos al clasificarlos como "0".

-   Verdaderos positivos (VP): La esquina inferior derecha (3368) representa el número de observaciones clasificadas correctamente como "1". Esto significa que el modelo         predijo correctamente 3368 casos como "1".


## KNN

El modelo KNN (K-Nearest Neighbors) es un algoritmo de aprendizaje supervisado que se utiliza tanto para clasificación como para regresión. Es un método basado en instancias que no hace supuestos sobre la forma funcional de la relación entre las variables independientes y la variable dependiente. KNN utiliza la información de los vecinos más cercanos para realizar predicciones.
Para ello calcula distancias como la Euclidiana, Manhattan, Minkowski, etc...

La idea detrás de KNN es simple, una observación se clasifica o se le asigna un valor basado en las características de sus K vecinos más cercanos.

Algunas ventajas del algoritmo KNN son su simplicidad, su capacidad para manejar relaciones no lineales entre variables; sin embargo también tiene algunas desventajas, como su sensibilidad a la maldición de la dimensionalidad, el efecto de las variables irrelevantes y el costo computacional asociado con el cálculo de distancias en conjuntos de datos grandes.

Procedemos al cálculo de este modelo e intentamos ver si hay un número correcto de k-vecinos que podemos usar.

```{r}
library(class)
long = 15
accuracy = rep(0,long)
f1score = rep(0,long)
recall = rep(0,long)
precision = rep(0,long)
for (i in 1:long)
{
  prediccion_knn_cv =knn.cv(mhp_train[,c("exterior","rooms","m2","elevator", "garage")], 
                            k=i, cl=mhp_train$precio_bin)
  accuracy[i] = sum(prediccion_knn_cv == mhp_train$precio_bin) /nrow(mhp_train)
  recall[i] = sum(prediccion_knn_cv == mhp_train$precio_bin & mhp_train$precio_bin == TRUE) / sum(mhp_train$precio_bin == TRUE)
  precision[i] = sum(prediccion_knn_cv == mhp_train$precio_bin & prediccion_knn_cv == TRUE) / sum(prediccion_knn_cv == TRUE)
  f1score[i] = 2*precision[i]*recall[i]/(precision[i]+recall[i])
}
resultados_knn = as.data.frame(cbind(accuracy,f1score,precision,recall))
resultados_knn = resultados_knn %>% mutate(index=as.factor(seq(1:long)))

max(resultados_knn$f1score)
which.max(resultados_knn$f1score)


ggplot(data=resultados_knn,aes(x=index,y=accuracy)) + 
  geom_col(colour="cyan4",fill="cyan3")+
  ggtitle("Accuracy")


ggplot(data=resultados_knn,aes(x=index,y=f1score)) + 
  geom_col(colour="orange4",fill="orange3") +
  ggtitle("F1_score values")

```

Tratamos de encontrar el valor óptimo de k utilizando validación cruzada. Se calculan varias métricas de evaluación, como precisión, recall y F1-score, para cada valor de k y finalmente tratamos de graficar la precisión en función del valor de k, pero analizando el gráfico no observamos ninguna diferencia, así que cogemos 5 que es el tamaño por defecto que se suele coger.


Pasamos a realizar predicciones en el conjunto de datos de entrenamiento y en el de test además de realizar la matriz de confusión.

```{r}
library(distances)
# En train
prediccion_knn5_train =knn.cv(mhp_train[,c("exterior","rooms","m2","elevator", "garage")], 
                              k=5, cl=mhp_train$precio_bin)
confusionMatrix(table(prediccion_knn5_train,mhp_train$precio_bin), positive= "1")

#En test
prediccion_knn5_test=knn(mhp_train[,c("exterior","rooms","m2","elevator", "garage")], mhp_test[,c("exterior","rooms","m2","elevator", "garage")],
                         k=5, cl=mhp_train$precio_bin)
confusionMatrix(table(prediccion_knn5_test,mhp_test$precio_bin), positive= "1")
```

La matriz de confusión en train nos muestra la cantidad de predicciones correctas e incorrectas de cada clase (1 y 0) en el conjunto de entrenamiento.

-   Accuracy (exactitud): 0.8482. Es la proporción de predicciones correctas en el conjunto de entrenamiento. En otras palabras, el modelo KNN clasifica correctamente el         84.82% de las observaciones del conjunto de entrenamiento.

-   Kappa: 0.6963. El índice kappa mide la concordancia entre las predicciones y los valores reales. Un kappa de 1 indica una concordancia perfecta, mientras que un kappa de     0 indica una concordancia totalmente aleatoria. Nuestro kappa de 0.6963 muestra una buena concordancia entre las predicciones y los valores reales en el conjunto de          entrenamiento.

-   Mcnemar's Test P-Value: 0.003201. Esta prueba evalúa si hay una diferencia significativa entre las predicciones falsas positivas y las predicciones falsas negativas. 

La matriz de confusión en test nos muestra valores muy parecidos en los indicadores anteriores lo que nos lleva a pensar que el modelo tiene un rendimiento consistente y generaliza bien lo datos ya que el modelo clasifica correctamente las observaciones y no parece sobreajustado.

Hemos realizado diferentes pruebas quitando variables y se observa que si quitamos la variable m2 nos dice que hay muchos empates.
Sin embargo, quitando las otras variables el acierto en train y test varía.

Obteniendo más o menos un 84% de acierto creemos que nos puede servir para clasificar las nuevas casas que entrasen en el dataset puesto que no hemos sido capaces de mejorar ese %.


## Decision Trees

El modelo de Árbol de Decisión es un algoritmo de aprendizaje supervisado que funciona dividiendo iterativamente el conjunto de datos en subconjuntos basados en las características del mismo. Al final de este proceso, se genera un árbol con nodos y hojas que representan las divisiones y las decisiones.

Algunas características importantes de los árboles de decisión son la interpretabilidad, capacidad para manejar datos no lineales, el poco preprocesamiento de los datos, la sensibilidad a datos desequilibrados y el posible sobreajuste en el caso de hacer un arbol con demasiadas ramificaciones.

A continuación hacemos el modelo de arbol de decisión. 

```{r}
library(rpart)
library(rpart.plot)
library(rattle)
arbol <- rpart(precio_bin ~ garage + elevator + rooms + tipo_casa + precio_distrito, data = mhp_train, control = rpart.control(minsplit = 1))
fancyRpartPlot(arbol, sub = "")
```
Para evaluar el modelo utilizamos la función predict sobre el conjunto test usando el argumento type = "class" que indica que se espera una salida categórica creandose una tabla de contingencias "tab1" con las predicciones que coinciden o no respecto a las observaciones reales.

Calculamos y obtenemos el número 0.8396275 que representa la tasa de acierto (accuracy) del modelo. El Árbol de Decisión hizo predicciones correctas en aproximadamente el 83.96% de los casos en el conjunto de datos de prueba. Nos parece un porcentaje bastante aceptable.

```{r}
tab1 = table(pred = predict(arbol, mhp_test, type = "class"),
obs = mhp_test$precio_bin)
ntest = nrow(mhp_test)
acierto1 = sum(diag(tab1))/ntest
acierto1
```

Siguiendo con la validación del modelo podemos usar las funciones printcp y plotcp que se utilizan para analizar la complejidad y el rendimiento usando el "pruning" o poda de ramas del arbol que a menudo reduce su complejidad y permite una mejor generalización del mismo disminuyendo el subreajuste.

La función printcp es una función que muestra una tabla que contiene información sobre la complejidad y la tasa de error en diferentes niveles de tamaño del árbol proporcionando una visión general de cómo cambia el rendimiento a medida que aumenta la complejidad. El valor de cp ha de ser tal que la tasa de error de validación cruzada sea mínima.

La función plotcp crea un gráfico de la tasa de error. Este gráfico es útil para visualizar cómo se comporta el rendimiento del árbol a medida que aumenta su tamaño y ayuda a decidir qué tamaño de árbol es el más apropiado para el problema en cuestión.

```{r}
printcp(arbol)
```

Obtenidos los resultados, pasamos a analizarlos:

-   CP (Cost Complexity): Mide la complejidad asociado con cada nivel de poda en el árbol de decisión. Un CP más pequeño indica una complejidad menor.
-   nsplit: Número de divisiones (splits) realizadas hasta el momento en el árbol.
-   rel error: Error relativo en cada etapa de poda del árbol.
-   xerror: Error de validación cruzada (cross-validated) estimado para el árbol en cada etapa de poda.
-   xstd: Desviación estándar del error de validación cruzada (xerror).

En base a los resultados presentados, se puede observar que el árbol sin poda tiene un error relativo de 1.0 y un error de validación cruzada de 1.0189.
A medida que se realizan más divisiones en el árbol el CP disminuye y también lo hace el error relativo y el error de validación cruzada.

Para seleccionar el árbol óptimo, generalmente se busca el CP más pequeño que tenga un error de validación cruzada dentro de una desviación estándar del mínimo error de validación cruzada.

```{r}
arbol$cptable[which.min(arbol$cptable[, "xerror"]),
"CP"]
```

El propósito es identificar el mejor árbol de decisión con respecto a su capacidad de generalización en datos no vistos. La función which.min() devuelve el índice del valor mínimo en la columna "xerror" de la tabla de complejidad cptable del árbol de decisión. Luego, con ese índice, se extrae el valor correspondiente de la columna "CP" en la tabla de complejidad.


```{r}
plotcp(arbol)
```
Podamos el árbol como indica la función. 

```{r}
pruneTREE1 = prune(arbol, cp = arbol$cptable[which.min(arbol$cptable[,
"xerror"]), "CP"])
fancyRpartPlot(pruneTREE1, uniform = TRUE, main = "Pruned Classification Tree",
sub = "")
```

```{r}
pruneTREE2 = prune(arbol, cp = arbol$cptable[5, "CP"])
fancyRpartPlot(pruneTREE2, uniform = TRUE, main = "Pruned Classification Tree",
sub = "")
```

```{r}
tab2 = table(pred = predict(pruneTREE2, mhp_test, type = "class"),
obs = mhp_test$precio_bin)
acierto2 = sum(diag(tab2))/ntest
acierto2
```
Tras la poda nos sale literalmente es mismo resultado.

Creamos la matriz de confusión. 

```{r}
prediccion_1 <- predict(arbol, newdata = mhp_train, type = "class")
```

```{r}
confusionMatrix(prediccion_1, mhp_train[["precio_bin"]])
```

Los resultados en la matriz de confusión son los siguientes:

-   Verdaderos positivos (VP): 3246 (casos en los que se predijo 1 y el valor real era 1)
-   Verdaderos negativos (VN): 3250 (casos en los que se predijo 0 y el valor real era 0)
-   Falsos positivos (FP): 619 (casos en los que se predijo 1 pero el valor real era 0)
-   Falsos negativos (FN): 617 (casos en los que se predijo 0 pero el valor real era 1)

También obtenemos:

-   Accuracy (exactitud): 84.01% de predicciones correctas.
-   Kappa: 68.03% 
-   Sensitivity (sensibilidad): 0.8403. También conocida como recall o tasa verdadera positiva, mide la proporción de casos positivos que se identificaron correctamente.
-   Specificity (especificidad): 0.8400. Mide la proporción de casos negativos que se identificaron correctamente. Un valor más alto es mejor.
-   Pos Pred Value (valor predictivo positivo): 0.8398. Mide la proporción de predicciones positivas que son realmente positivas. Un valor más alto es mejor.
-   Neg Pred Value (valor predictivo negativo): 0.8404. Mide la proporción de predicciones negativas que son realmente negativas. Un valor más alto es mejor.
-   Mcnemar's Test P-Value: 0.9773. Esta prueba compara las diferencias entre los falsos positivos y los falsos negativos. Un valor alto de "p" (como en este caso) sugiere       que no hay una diferencia significativa entre ellos.

En resumen, este modelo de árbol de decisión podado tiene una exactitud del 84.01% y un coeficiente kappa de 0.6803, lo que indica un buen rendimiento en la clasificación.


## Random Forest

Algoritmo de aprendizaje supervisado que se basa en la construcción de múltiples árboles de decisión durante el entrenamiento y la combinación de sus resultados para hacer una predicción. El objetivo principal de este enfoque es mejorar la precisión y la robustez del modelo en comparación con un único árbol de decisión.

El funcionamiento de un algoritmo Random Forest sería el siguiente:

-   Seleccionar muestras de arranque: El algoritmo selecciona aleatoriamente un subconjunto de muestras del conjunto de datos de entrenamiento, con reemplazo. 
    Esto significa que una muestra puede ser seleccionada más de una vez.

-   Crear un árbol de decisión: Se crea un árbol de decisión utilizando el subconjunto de muestras seleccionado. Durante la construcción del árbol, en cada división del nodo,     se selecciona un subconjunto aleatorio de características como candidatas para la división. 
    La mejor división se elige en función de la medida de impureza como la entropía o el índice de Gini. Esto introduce aleatoriedad adicional en el proceso, lo que ayuda a      reducir la correlación entre los árboles.

-   Repetir: El proceso se repite varias veces (número de árboles especificado) para construir un conjunto de árboles de decisión.

-   Combinar las predicciones: Para hacer una predicción en un nuevo caso, el algoritmo Random Forest ejecuta todos los árboles individualmente y luego combina sus               resultados. En el caso de la clasificación, la clase con más votos (predicciones) de todos los árboles se elige como la predicción final.

Pasamos a construir el modelo comenzando con 10 árboles aleatórios.

```{r}
library(randomForest)
# Escalamos la columna 4 en train y test
set.seed(19042023)
mhp_train_scaled <- mhp_train
mhp_train_scaled[, 4] <- scale(mhp_train[, 4])

mhp_test_scaled <- mhp_test
mhp_test_scaled[, 4] <- scale(mhp_test[, 4])

# Nos quedamos con todas las variables menos barrio y distrito porque hay muchas categorias
# Cogemos solo 10 árboles en el parámetro ntree
classifier <- randomForest(x = mhp_train_scaled[, c(3, 4, 5, 6, 7, 10,11)],
                           y = mhp_train_scaled$precio_bin,
                           ntree = 10)
```

```{r}
# Predicción de los resultados con el conjunto de testing
y_pred = predict(classifier, newdata = mhp_test_scaled[,c(3,4,5,6,7,10,11)])
```

```{r}
confusionMatrix(y_pred, mhp_test_scaled[["precio_bin"]])
```
Ahora probamos con 100 árboles aleatorios para ver si cambia mucho el resultado. 

```{r}
set.seed(19042022)
classifier <- randomForest(x = mhp_train_scaled[, c(3, 4, 5, 6, 7, 10,11)],
                           y = mhp_train_scaled$precio_bin,
                           ntree = 100)
```

```{r}
y_pred = predict(classifier, newdata = mhp_test_scaled[,c(3,4,5,6,7,10,11)])
```


```{r}
confusionMatrix(y_pred, mhp_test_scaled[["precio_bin"]])
```
La precisión del modelo es del 0,9077 y el intervalo de confianza del 95% es (0,8908, 0,9099), lo que indica que podemos estar bastante seguros de que la precisión real del modelo está dentro de este rango. El valor de kappa de 0,8013 indica que hay una buena concordancia entre las predicciones del modelo y las observaciones reales.

Además, la sensibilidad del modelo es del 0,8670 y la especificidad del 0,9343. La tasa de detección es del 0,4335 y la prevalencia es del 0,5000. En general, el modelo tiene un desempeño bastante bueno en la clasificación de las viviendas por encima y por debajo del umbral.


## SVM

Support Vector Machine, algoritmo de aprendizaje supervisado que se utiliza tanto para problemas de clasificación como de regresión. En el caso de la clasificación, el objetivo principal de SVM es encontrar el hiperplano óptimo que separa los datos en diferentes clases. Un hiperplano es un límite de decisión que divide el espacio de características en dos partes, de modo que cada parte contenga puntos de datos de una clase específica. En el caso de la regresión, SVM busca encontrar una función que tenga el menor error de ajuste posible.

El algoritmo SVM funciona de la siguiente manera:

-   Encuentra el hiperplano óptimo: El algoritmo busca el hiperplano que tenga el margen máximo entre las dos clases. El margen es la distancia entre el hiperplano y los         puntos de datos más cercanos a él, llamados "vectores de soporte". Estos vectores de soporte son los puntos de datos que definen el límite de decisión y son fundamentales     para el proceso de SVM.

-   Solución de un problema de optimización: La búsqueda del hiperplano óptimo implica la solución de un problema de optimización convexa. Este problema se resuelve mediante     técnicas de optimización como el método de Lagrange o el algoritmo de optimización secuencial mínima (SMO).

-   Transformación a través del kernel: En casos en los que los datos no son linealmente separables en el espacio de características original, SVM puede utilizar una función     de kernel para transformar los datos en un espacio de características de mayor dimensión donde se puedan separar linealmente. Los kernels comunes incluyen el kernel          lineal, el kernel polinómico, el kernel de base radial (RBF) y el kernel sigmoide. La elección del kernel adecuado es crucial para el rendimiento del modelo SVM.

-   Clasificación: Para hacer una predicción en un nuevo punto de datos, el algoritmo SVM evalúa la posición del punto con respecto al hiperplano óptimo. Si el punto está por     encima del hiperplano, se asigna a una clase, y si está por debajo, se asigna a la otra clase.

Para resolver de SVM necesito conocer el kernel y el parámetro de regularización que es una cuota superior sobre las variables duales, en definitiva, un coste. Pasamos a construir  un primer el modelo usando un kernel radial RBF.

```{r}
library(e1071)
library(kernlab)

# Estandarizamos las variables numéricas "m2" y "rooms"
mhp_train$m2_estandarizado <- scale(mhp_train$m2)
mhp_train$rooms_estandarizado <- scale(mhp_train$rooms)

mhp_test$m2_estandarizado <- scale(mhp_test$m2)
mhp_test$rooms_estandarizado <- scale(mhp_test$rooms)

# Entrenamos el modelo SVM  kernel con kernel radial

modelo_svm <- svm(precio_bin ~ rooms_estandarizado + m2_estandarizado + garage + elevator + tipo_casa + precio_distrito, data = mhp_train, kernel = "radial", cost = 10, scale = TRUE)

# Hacemos predicciones en el conjunto de prueba
svm_predicciones <- predict(modelo_svm, mhp_test[, c("rooms_estandarizado", "m2_estandarizado", "garage", "elevator", "tipo_casa", "precio_distrito")])


# Calculamos la matriz de confusión y la precisión del modelo
svm_matriz_confusion <- table(Prediccion = svm_predicciones, Real = mhp_test$precio_bin)
print(svm_matriz_confusion)
precision <- sum(diag(svm_matriz_confusion)) / sum(svm_matriz_confusion)
print(paste0("Precisión del modelo SVM: ", round(precision * 100, 2), "%"))
```

Esto significa que:

-   1692 casas con precio alto fueron clasificadas correctamente como precio alto (verdaderos positivos).
-   1817 casas con precio bajo fueron clasificadas correctamente como precio bajo (verdaderos negativos).
-   241 casas con precio alto fueron clasificadas incorrectamente como precio bajo (falsos negativos).
-   116 casas con precio bajo fueron clasificadas incorrectamente como precio alto (falsos positivos).

La precisión del modelo es del 90.77%.

\

ELECCION DEL KERNEL

La elección del kernel en un modelo SVM depende de la naturaleza y la distribución de los datos. No hay una regla única para seleccionar el kernel, pero aquí hay algunas pautas generales para ayudarte a tomar una decisión:

-   Kernel lineal: Si tus datos son linealmente separables o la cantidad de atributos es alta en comparación con la cantidad de muestras, entonces un kernel lineal suele         funcionar bien. Además, es computacionalmente más eficiente que otros kernels.

-   Kernel polinomial: Si tus datos tienen una estructura que puede ser capturada por un polinomio de un grado específico, el kernel polinomial podría ser una buena opción.      Sin embargo, a medida que aumenta el grado del polinomio, el riesgo de sobreajuste aumenta y la complejidad computacional puede crecer.

-   Kernel radial (RBF): El kernel radial es una opción popular y versátil en muchos casos, especialmente cuando no se sabe de antemano si los datos son linealmente              separables. Puede manejar datos no lineales y complejos. Sin embargo, encontrar los parámetros adecuados (costo y gamma) puede requerir una búsqueda en el espacio de         parámetros y, en consecuencia, un mayor tiempo de cómputo.

-   Kernel sigmoide: El kernel sigmoide es similar a una función de activación de una red neuronal y puede ser una opción si deseas un enfoque similar al de una red neuronal     pero con un modelo SVM.


Vamos a probar a representar los datos para ver si de alguna manera puede tomarse una mejor decisión sobre el Kernel a usar.

```{r}
mhp_train %>%
  ggplot(aes(x = m2, y = rooms, color = as.factor(precio_bin))) +
  geom_point() +
  facet_grid(elevator ~ garage, labeller = labeller(
    elevator = c('0' = 'Sin Elevador', '1' = 'Con Elevador'),
    garage = c('0' = 'Sin Garaje', '1' = 'Con Garaje')
  )) +
  labs(title = "Diagrama de dispersión de m2 vs rooms, según garage y elevator",
       x = "Metros cuadrados",
       y = "Número de habitaciones",
       color = "Precio bin") +
  scale_color_manual(values = c("1" = "#0BB363", "0" = "#DC143C")) +
  theme_minimal() +
  theme(plot.title = element_text(hjust = 0.5, face = "bold"),
        plot.title.position = "plot")
```

\

Probamos varios KERNELS

Creamos una función entrenar_evaluar_svm() que entrenará y evaluará un modelo SVM utilizando el tipo de kernel especificado en el argumento kernel_type. Luego con lapply() se aplicará esta función a cada tipo de kernel en el vector kernels. La función presentará un matriz de confusión y la precisión para cada tipo de kernel.

```{r}
# Definir una función para entrenar y evaluar un modelo SVM con un tipo de kernel específico
entrenar_evaluar_svm <- function(kernel_type) {
  # Entrenamos el modelo SVM con el kernel especificado
  modelo_svm <- svm(precio_bin ~ rooms_estandarizado + m2_estandarizado + garage + elevator + tipo_casa + precio_distrito, data = mhp_train, kernel = kernel_type, cost = 10, scale = TRUE)

  # Hacemos predicciones en el conjunto de prueba
  svm_predicciones <- predict(modelo_svm, mhp_test[, c("rooms_estandarizado", "m2_estandarizado", "garage", "elevator", "tipo_casa", "precio_distrito")])

  # Calculamos la matriz de confusión y la precisión del modelo
  svm_matriz_confusion <- table(Prediccion = svm_predicciones, Real = mhp_test$precio_bin)
  precision <- sum(diag(svm_matriz_confusion)) / sum(svm_matriz_confusion)
  
  # Devolvemos una lista con la precisión y la matriz de confusión
  return(list(precision = precision, matriz_confusion = svm_matriz_confusion))
}

# Probar diferentes tipos de kernel
kernels <- c("linear", "polynomial", "radial", "sigmoid")
resultados <- lapply(kernels, entrenar_evaluar_svm)

# Imprimir los resultados
for (i in 1:length(kernels)) {
  cat(paste("Precisión del modelo SVM con kernel", kernels[i], ":", round(resultados[[i]]$precision * 100, 2), "%\n"))
  print(resultados[[i]]$matriz_confusion)
}
```

Se observa que el KERNEL RADIAL es el que mejor predice, ahora vamos a ajustar algunos parámetros del modelo utilizando la función tune para encontrar los mejores parámetros.

```{r}
# Entrenar un modelo SVM con diferentes parámetros
modelo_svm_radial <- svm(precio_bin ~ rooms_estandarizado + m2_estandarizado + garage + elevator + tipo_casa + precio_distrito, data = mhp_train, kernel = "radial", cost = 10, scale = TRUE)

# Utilizar la función tune() para encontrar los mejores parámetros
tuned_parameters <- tune(svm, 
                         precio_bin ~ rooms_estandarizado + m2_estandarizado + garage + elevator + tipo_casa + precio_distrito,
                         data = mhp_train,
                         kernel = "radial",
                         ranges = list(cost = c(0.1, 1, 10, 100, 1000),
                                       gamma = c(0.1, 0.5, 1, 2, 5)))

# Entrenar un modelo SVM con los mejores parámetros encontrados
best_model <- tuned_parameters$best.model

# Hacer predicciones en el conjunto de prueba con el mejor modelo
best_predictions <- predict(best_model, mhp_test[, c("rooms_estandarizado", "m2_estandarizado", "garage", "elevator", "tipo_casa", "precio_distrito")])

# Calcular la matriz de confusión y la precisión del mejor modelo
best_matriz_confusion <- table(Prediccion = best_predictions, Real = mhp_test$precio_bin)
print(best_matriz_confusion)
best_precision <- sum(diag(best_matriz_confusion)) / sum(best_matriz_confusion)
print(paste0("Precisión del mejor modelo SVM: ", round(best_precision * 100, 2), "%"))
```
La precisión del modelo no mejora del 90.77% anterior y el coste computacional en la busqueda del mejor modelo es enorme.  Parece que los parámetros del modelo elegidos durante el proceso de afinación no han sido los correctos. La afinación e hiperparámetros implica buscar la mejor combinación de hiperparámetros dentro del rango de búsqueda que se proporciona. Si el rango de búsqueda no contiene la combinación óptima de hiperparámetros, el proceso de afinación podría terminar eligiendo una combinación subóptima que resulte en un rendimiento inferior.

\

No es posible representar directamente el hiperplano en un gráfico bidimensional. Sin embargo, podemos intentar visualizar pares de variables y su relación con la clasificación en el espacio bidimensional. Vamos a representar las variables m2_estandarizado y rooms_estandarizado.


```{r}
# Crear un nuevo dataframe con las variables y las predicciones
resultados <- cbind(mhp_test[, c("rooms_estandarizado", "m2_estandarizado", "garage", "elevator", "tipo_casa", "precio_distrito")], svm_predicciones)

# Graficar pares de variables con colores según la predicción
pairs(resultados, col = as.integer(resultados$svm_predicciones) + 1)
```




# Evaluación y comparación de modelos

# Elección punto de corte

# Redes Bayasianas y/o GAM



